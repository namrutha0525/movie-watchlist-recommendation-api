1ï¸âƒ£ Problem Statement

With the increasing availability of digital content, users often struggle to track movies they want to watch and discover new movies that match their interests. Most platforms provide recommendations, but users do not have control over managing personalized watchlists or understanding how recommendations are generated.

The objective of this project is to build a RESTful Movie Watchlist & Recommendation API using Go that integrates with an external movie database (OMDB API). The system allows users to:

Search for movies

Add movies to a watchlist

Rate watched movies

Receive personalized recommendations based on ratings and genres

This system demonstrates backend development skills including API design, database management, caching strategies, authentication, and recommendation logic implementation.

2ï¸âƒ£ Objectives

The primary objectives of this project are:

Develop a RESTful API using Go (Golang) and Gin framework.

Integrate with the OMDB external movie API.

Implement user authentication using JWT.

Design a relational database schema using PostgreSQL.

Implement Redis caching to reduce external API calls.

Develop a basic recommendation engine based on:

User ratings

Preferred genres

Ensure scalability, security, and maintainability of the system.

Provide clear API documentation and structured project design.

3ï¸âƒ£ Architecture
ğŸ— Architecture Overview

This project follows a Clean Architecture pattern to ensure separation of concerns and maintainability.

Layers:
1. Presentation Layer

Handles HTTP requests and responses.

Implemented using Gin framework.

Contains route handlers and middleware.

2. Service Layer

Contains business logic.

Handles recommendation logic.

Communicates with external APIs.

Implements caching logic.

3. Data Layer

PostgreSQL database using GORM ORM.

Redis cache layer.

Handles data persistence and retrieval.

4. External Integration Layer

Integrates with OMDB API to fetch movie data.

ğŸ” Request Flow

Client sends HTTP request.

Middleware validates JWT (if required).

Handler receives request.

Service layer processes business logic.

Service checks Redis cache:

If data exists â†’ return cached result.

If not â†’ fetch from OMDB â†’ store in Redis â†’ return response.

Response returned as JSON.

4ï¸âƒ£ Recommendation Logic Explanation

The recommendation engine is rule-based and genre-driven.

ğŸ¯ Strategy Used

When a user rates a movie:

The system stores the rating and genre.

The system identifies:

Highest-rated genres by that user.

Recommendations are generated by:

Fetching movies from the userâ€™s top-rated genres.

Excluding already watched movies.

Prioritizing movies with higher external ratings.

ğŸ“Œ Example

If a user highly rates:

Action movies

Sci-Fi movies

The system recommends:

Popular Action movies

Trending Sci-Fi movies

âš™ Algorithm Steps

Fetch user ratings.

Group ratings by genre.

Calculate average rating per genre.

Select top 1â€“2 genres.

Fetch movies of those genres from OMDB.

Filter movies already watched.

Return top results.

This approach provides personalized yet simple recommendations.

5ï¸âƒ£ Caching Explanation
ğŸš€ Why Caching is Needed

OMDB is an external API:

Has rate limits.

Slower than internal DB.

May incur cost or restrictions.

To optimize performance, Redis is used.

ğŸ”´ Redis Caching Strategy
What is Cached?

Movie search results

Movie details fetched from OMDB

Cache Key Structure

movie:search:{query}
movie:details:{imdbID}

â³ Expiration Strategy

Cached results expire after a fixed TTL (e.g., 6 hours).

Ensures data freshness.

Reduces unnecessary external API calls.

âš¡ Benefits

Faster response time

Reduced OMDB API calls

Lower external dependency risk

Better scalability under high traffic

6ï¸âƒ£ Security

Security measures implemented in this project:

ğŸ” 1. JWT Authentication

Users must log in to:

Add watchlist items

Rate movies

Get recommendations

JWT token is validated in middleware.

ğŸ”‘ 2. Password Hashing

Passwords stored using bcrypt hashing.

Plain text passwords are never stored.

ğŸ›¡ 3. Input Validation

Request body validation.

Prevents malformed inputs.

Protects against injection attacks.

ğŸ”’ 4. Environment Variables

Sensitive data stored in .env:

Database credentials

OMDB API key

JWT secret

Redis configuration

7ï¸âƒ£ Scalability

The system is designed to scale efficiently.

ğŸ“ˆ Horizontal Scalability

Stateless API design.

JWT-based authentication (no session storage).

Can deploy multiple instances behind load balancer.

ğŸ“Š Database Optimization

Proper indexing:

user_id

imdb_id

Efficient foreign key constraints.

Optimized queries via GORM.

ğŸš€ Caching for Performance

Redis reduces:

External API load

Database read load

Latency

ğŸ³ Containerization Ready

The project can be containerized using Docker:

Go API container

PostgreSQL container

Redis container

This makes deployment scalable and production-ready.
